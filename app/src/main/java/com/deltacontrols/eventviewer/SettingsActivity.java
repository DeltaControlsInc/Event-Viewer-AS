/* Copyright (c) 2014, Delta Controls Inc.
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, 
are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this 
list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice, this 
list of conditions and the following disclaimer in the documentation and/or other 
materials provided with the distribution.

3. Neither the name of the copyright holder nor the names of its contributors may 
be used to endorse or promote products derived from this software without specific 
prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT 
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR 
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) 
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE 
POSSIBILITY OF SUCH DAMAGE.
*/
package com.deltacontrols.eventviewer;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;

import android.app.Activity;
import android.content.Context;
import android.content.Intent;
import android.os.Bundle;
import android.os.Handler;
import android.view.Gravity;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.Spinner;
import android.widget.TextView;
import android.widget.Toast;

import com.deltacontrols.eventviewer.service.ScheduleEventNotifications;
import com.deltacontrols.eweb.support.api.EwebConnection;
import com.deltacontrols.eweb.support.api.EwebConnection.CONNECTION_STATUS;
import com.deltacontrols.eweb.support.api.FetchJSON;
import com.deltacontrols.eweb.support.api.FetchJSON.Result;
import com.deltacontrols.eweb.support.interfaces.GenericCallback;

import org.apache.http.HttpStatus;
import org.json.JSONObject;

/**
 * Settings/Login page
 */
public class SettingsActivity extends Activity {
    /**
     * Extends an ArrayList to allow search by string
     */
    private class searchableStringArrayList extends ArrayList<String> {
        private static final long serialVersionUID = 2526795240635839538L; // Autogenerated

        public searchableStringArrayList(List<String> list) {
            super(list);
        }

        public int getIndexFor(int iStr) {
            String str = String.valueOf(iStr);
            return getIndexFor(str);
        }

        public int getIndexFor(String str) {
            for (int i = 0; i < this.size(); i++) {
                if (this.get(i).equals(str)) {
                    return i;
                }
            }
            return -1;
        }
    }

    // ------------------------------------------------------------------------------
    // Outlets
    // ------------------------------------------------------------------------------
    private TextView mUrl;
    private TextView mUser;
    private TextView mPass;
    private Spinner mRefreshTimeSpinner;
    private Button mLogin;
    private EwebConnection eweb;
    private LoginInfo mLoginInfo;

    // ------------------------------------------------------------------------------
    // Properties
    // ------------------------------------------------------------------------------
    private static int mRefreshTimeDefaultIndex = 3;        // 5 mins.
    private searchableStringArrayList mRefreshTimeValues;   // Custom class; see above

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_settings);

        eweb = App.getEwebConnection();
        mLoginInfo = LoginInfo.getLoginInfo(this);

        mUrl = (TextView) findViewById(R.id.url);
        mUser = (TextView) findViewById(R.id.user_name);
        mPass = (TextView) findViewById(R.id.password);
        mRefreshTimeSpinner = (Spinner) findViewById(R.id.refreshTimeSpinner);
        mRefreshTimeValues = new searchableStringArrayList(Arrays.asList(this.getResources().getStringArray(R.array.refresh_time_array_values)));

        // Login button
        mLogin = (Button) findViewById(R.id.loginButton);
        mLogin.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View v) {
                TextView url = (TextView) findViewById(R.id.url);
                TextView user = (TextView) findViewById(R.id.user_name);
                TextView pass = (TextView) findViewById(R.id.password);

                mLogin.setEnabled(false);

                final String urlStr;
                final String userStr = user.getText().toString();
                final String passStr = pass.getText().toString();
              
                // If all empty, set demo and continue
                if (url.getText().toString().isEmpty() && userStr.isEmpty() && passStr.isEmpty()) {
                    LoginInfo.deleteStoredLoginInfo(SettingsActivity.this);
                    // Launch main activity
                    Intent intent = new Intent(App.getContext(), MainActivity.class);
                    startActivity(intent);
                    finish();
                }
                else {
                	if (!url.getText().toString().contains("http")) {
                		urlStr  = String.format("http://%s", url.getText().toString());
                	}
                	else
                		urlStr = url.getText().toString();

                    mLoginInfo.url = urlStr;
                    mLoginInfo.username = userStr;
                    mLoginInfo.password = passStr;
                    // Allow retry in case it does not used basic authentication
                    mConnectRetry = true;

                    // Else, attempt login
                    // try using basic authentication method
                    eweb.connect(mLoginInfo.url, mLoginInfo.username, mLoginInfo.password, connectListener,true);
                }
            }
        });

        // Setup login information and auto sync if the user is currently active.
        mUrl.setText(mLoginInfo.url);
        mUser.setText(mLoginInfo.username);
        mPass.setText(mLoginInfo.password);

        // Set refresh time; do lookup of value to get text index
        int refreshIndex = mRefreshTimeValues.getIndexFor(mLoginInfo.refreshSeconds);
        if (refreshIndex == -1) {
            refreshIndex = mRefreshTimeDefaultIndex;
        }
        mRefreshTimeSpinner.setSelection(refreshIndex);

        // Enable/disable based on if user is logged in / active
        if (mLoginInfo.active) {
            mLogin.setVisibility(View.GONE);
            mUrl.setEnabled(false);
            mUser.setEnabled(false);
            mPass.setEnabled(false);
        }
        else {
            mLogin.setVisibility(View.VISIBLE);
            mUrl.setEnabled(true);
            mUser.setEnabled(true);
            mPass.setEnabled(true);
        }
    }

    // This is handler is used to call the old authentication when the new authentication fail.
    Handler connectHandler = new Handler(); // Handler for the refresh functionality
    private final long mConnetTimeout = 10; // Refresh timeout in milliseconds
    private boolean mConnectRetry = true;
    private Runnable connectTask = new Runnable() { // Runnable task executed by the handler via timeout
      @Override
      public void run() {
        if (eweb.getConnectionStatus() != EwebConnection.CONNECTION_STATUS.OK){
          eweb.disconnect();
          eweb.connect(mLoginInfo.url, mLoginInfo.username, mLoginInfo.password, connectListener);
          // Only does once
          stopReconnect();
        }

      }
    };

    private void startReconnect(long delayMs) {
      connectHandler.removeCallbacks(connectTask);
      connectHandler.postDelayed(connectTask, delayMs);
    }

    private void stopReconnect() {
      connectHandler.removeCallbacks(connectTask);
    }

    private GenericCallback<FetchJSON.Result> connectListener = new GenericCallback<FetchJSON.Result>() {
      @Override
      public void onCallback(FetchJSON.Result result) {
        if (eweb.getConnectionStatus() == CONNECTION_STATUS.OK) {
          mLoginInfo.active = true;
          mLoginInfo.mBasicAuthentication = eweb.getBasicAuthenticationFlag();
          mLoginInfo.setLoginInfo(App.getContext(), mLoginInfo);

          // Start up the service immediately.
          ScheduleEventNotifications.startServiceRepeating(App.getContext(), 0, mLoginInfo.refreshSeconds);

          // Launch main activity
          Intent intent = new Intent(App.getContext(), MainActivity.class);
          startActivity(intent);
          finish();
        } else {
          if ((result.statusCode == HttpStatus.SC_BAD_REQUEST) || (result.statusCode == HttpStatus.SC_UNAUTHORIZED)) {
            if (mConnectRetry) {
              mConnectRetry = false;
              startReconnect(mConnetTimeout);
            }
          } else {
              String errorMessage = errorMessage = getString(R.string.login_activity_failed_to_login);

              if (result.statusCode == 418){
                errorMessage = getString(R.string.notification_network_connection_issue);
              }
            else {
                Iterator<String> keys;
                String errorTxt = null;
                String refTxt = null;
                // Get the list of keys
                keys = result.json.keys();
                while(keys.hasNext()){
                  try{
                    refTxt = keys.next();
                    if (refTxt.contains("errorText")){
                      errorTxt = result.json.get(refTxt).toString();
                      if (!errorTxt.isEmpty()){
                        errorMessage = errorTxt;
                      }
                    }
                  }catch (Exception e){
                    // do nothing here. error message already initialize to default
                  }
                }
              }

            if (eweb.getConnectionStatus() == CONNECTION_STATUS.ERROR_INVALID_APPS_LICENSE) {
              ShowCustomToast(SettingsActivity.this, getString(R.string.login_activity_server_invalid_apps_license), Toast.LENGTH_LONG);
            } else {
              ShowCustomToast(SettingsActivity.this, errorMessage, Toast.LENGTH_LONG);
            }
          }
        }
        mLogin.setEnabled(true);
      }

    };


    @Override
    protected void onPause() {
        super.onPause();

        try {
            // Get refresh seconds, and if they are different than the stored settings, update and restart service.
            String refreshTime = mRefreshTimeValues.get(mRefreshTimeSpinner.getSelectedItemPosition());

            int refreshInt = Integer.parseInt(refreshTime);
            LoginInfo login = LoginInfo.getLoginInfo(App.getContext());
            if (login.refreshSeconds != refreshInt) {
                login.refreshSeconds = refreshInt;
                LoginInfo.setLoginInfo(App.getContext(), login);

                // Restart service if user is active (ie. we are logged in)
                if (LoginInfo.storedUserIsActive(this)) {
                    ScheduleEventNotifications.stopServiceRepeating(this);
                    ScheduleEventNotifications.startServiceRepeating(this, 0, refreshInt);
                }
            }
        } catch (Exception e) {
        	ShowCustomToast(this, getString(R.string.login_activity_problem_saving_settings), Toast.LENGTH_LONG);
        }
    }
    
	public void ShowCustomToast(Context context, String textMessage, int duration) {
    	Toast cusToast = Toast.makeText(context, textMessage, duration);
    	
    	cusToast.setGravity(Gravity.CENTER_VERTICAL, 0, 0);
    	cusToast.show();	    	
	}    
    
}
